grf {
    grfid:                  "BY\01\01";
    name:                   string(STR_GRF_NAME);
    desc:                   string(STR_GRF_DESCRIPTION);
    url:                    string(STR_GRF_URL);
    version:                0;
    min_compatible_version: 0;
}

if (!extended_feature_test("action3_signals_custom_signal_sprites")) {
    error(FATAL, string(STR_UNSUPPORTED_VERSION));
}

// Commented by osswix and big mostly

// template for spriteset :
// spriteset([name], "file location"){[template_specific](x,y)}
// where file location is the location of the image containing the sprites
// template_specific is the template relevant to the sprites
// x and y are the starting coordinates of the first sprite in the set
//
// For this american set the following setup will be used
//
// For single aspect signals there will be three states:
// CLR  clear
// APR  approach
// STP  stop
//
// for two aspect signals there is a more extended variety of states,
// these states differe between block and path signals to somewhat
// emulate a realistic situation, the states are as follows
//
// for 2 aspect block signals:
// CLR  clear
// AAL  advanced approach limited
// APM  approach medium
// AAP  advanced approach
// APR  approach
// STP  stop
//
// for 2 aspect path signals:
// CLR  clear
// MCL  medium clear
// APR  approach
// STP  stop
//
// for 3 aspect block signals:
// CLR  clear
// AAL  advanced approach limited
// APM  approach medium
// APS  approach slow
// APR  approach
// STP  stop
//
// for 3 aspect path signals:
// CLR  clear
// LCL  limited clear
// MCL  medium clear
// SCL  slow clear
// STP  stop
//
// the following abbriviations are used
// SA, DA, TA for single, double, and triple aspect respectively
// B for block and P for path.
// S for semaphore and L for light with other variations to later be added.

/*
The graphics are organized into a grid.
Each column cycles between RYG, then by orientation.
Each row is exactly 3 aspects, based on secondary aspect.
The rows are ordered as:
- single-head
- double-head, G top
- double-head, Y top
- double-head, R top
*/

// template [template name](x, y){
//  [x, y, sizex, sizey, offsetx offsety]
// }

/*
Each signal is 16x32px, with 1 pixel in between on all sides.
=> Each signal has their top left corner on (17i, 33j), where i >= 0 and j >= 0.
Different orientations of the same aspect are located on the same row, 17*3 = 51px on the x-axis.
*/
template aspect_cell(x, y, n) { [x+17*3*n, y, 16, 32, -8, -32] }

// x and y are the 0-indexed col/row number of the signal
template aspect(aspectColumn, signalRow) {
    aspect_cell(17*aspectColumn, 33*signalRow, 0)
    aspect_cell(17*aspectColumn, 33*signalRow, 1)
    aspect_cell(17*aspectColumn, 33*signalRow, 2)
    aspect_cell(17*aspectColumn, 33*signalRow, 3)
    aspect_cell(17*aspectColumn, 33*signalRow, 4)
    aspect_cell(17*aspectColumn, 33*signalRow, 5)
    aspect_cell(17*aspectColumn, 33*signalRow, 6)
    aspect_cell(17*aspectColumn, 33*signalRow, 7)
}


// single aspects
// singe-aspect semaphores
spriteset(signal_SABP_S_CLR, "gfx/1-and-2-head.png"){aspect(2, 0)}
spriteset(signal_SABP_S_APR, "gfx/1-and-2-head.png"){aspect(1, 0)}
spriteset(signal_SABP_S_STP, "gfx/1-and-2-head.png"){aspect(0, 0)}
// singe-aspect lights
spriteset(signal_SABP_L_CLR, "gfx/1-and-2-head.png"){aspect(2, 4)}
spriteset(signal_SABP_L_APR, "gfx/1-and-2-head.png"){aspect(1, 4)}
spriteset(signal_SABP_L_STP, "gfx/1-and-2-head.png"){aspect(0, 4)}

// double aspect semaphores
spriteset(signal_DAB_S_CLR, "gfx/1-and-2-head.png"){aspect(2, 1) aspect(0, 1)} // both GG and GR
spriteset(signal_DAB_S_AAL, "gfx/1-and-2-head.png"){aspect(1, 1)}
spriteset(signal_DAB_S_APM, "gfx/1-and-2-head.png"){aspect(1, 2)} // YY
spriteset(signal_DAB_S_AAP, "gfx/1-and-2-head.png"){aspect(2, 2)} // YG
spriteset(signal_DAB_S_APR, "gfx/1-and-2-head.png"){aspect(0, 2)}
spriteset(signal_DAB_S_STP, "gfx/1-and-2-head.png"){aspect(0, 3)}

spriteset(signal_DAP_S_CLR, "gfx/1-and-2-head.png"){aspect(2, 1) aspect(0, 1)}
spriteset(signal_DAP_S_MCL, "gfx/1-and-2-head.png"){aspect(2, 3)}
spriteset(signal_DAP_S_APR, "gfx/1-and-2-head.png"){aspect(0, 2)}
spriteset(signal_DAP_S_STP, "gfx/1-and-2-head.png"){aspect(0, 3)}

// double aspect lights
spriteset(signal_DAB_L_CLR, "gfx/1-and-2-head.png"){aspect(2, 5) aspect(0, 5)} // both GG and GR
spriteset(signal_DAB_L_AAL, "gfx/1-and-2-head.png"){aspect(1, 5)}
spriteset(signal_DAB_L_APM, "gfx/1-and-2-head.png"){aspect(2, 6)} // YG
spriteset(signal_DAB_L_AAP, "gfx/1-and-2-head.png"){aspect(1, 6)}
spriteset(signal_DAB_L_APR, "gfx/1-and-2-head.png"){aspect(0, 6)}
spriteset(signal_DAB_L_STP, "gfx/1-and-2-head.png"){aspect(0, 7)}

spriteset(signal_DAP_L_CLR, "gfx/1-and-2-head.png"){aspect(2, 5) aspect(0, 5)}
spriteset(signal_DAP_L_MCL, "gfx/1-and-2-head.png"){aspect(2, 7)}
spriteset(signal_DAP_L_APR, "gfx/1-and-2-head.png"){aspect(0, 6)}
spriteset(signal_DAP_L_STP, "gfx/1-and-2-head.png"){aspect(0, 7)}

// // triple aspects semaphores
// spriteset(signal_TAB_S_CLR, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAB_S_AAL, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAB_S_APM, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAB_S_APS, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAB_S_APR, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAB_S_STP, "gfx/1-and-2-head.png"){aspect()}

// spriteset(signal_TAP_S_CLR, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAP_S_LCL, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAP_S_MCL, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAP_S_SCL, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAP_S_STP, "gfx/1-and-2-head.png"){aspect()}

// // triple aspect lights
// spriteset(signal_TAB_L_CLR, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAB_L_AAL, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAB_L_APM, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAB_L_APS, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAB_L_APR, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAB_L_STP, "gfx/1-and-2-head.png"){aspect()}

// spriteset(signal_TAP_L_CLR, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAP_L_LCL, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAP_L_MCL, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAP_L_SCL, "gfx/1-and-2-head.png"){aspect()}
// spriteset(signal_TAP_L_STP, "gfx/1-and-2-head.png"){aspect()}

//Switches use the following format:
//switch(FEAT_SIGNALS, SELF, [name], [variable]{
//  value: result;
//  value: result;
//  return result; //Giving a "return result" at the end will give a default value when none of the other values have been met by the variable
//}
//The name can be any text string you like.
//The variables are pre-selected here to give the correct results
//The result can be a spriteset or another switch
//
//This switch decides which spriteset to use for each signal aspect for one signal type
//
//These are the templates of all switches in 'chronological' order:
//
// first bit is order of aspects, with a maximum of 7 (0-6)
//switch(FEAT_SIGNALS, SELF, newname, getbits(extra_callback_info2, 0, 8)){
//  00: stop signal;
//  01: highest clearance;
//  05: one step lower:
//  04: one step lower:
//  03: one step lower:
//  02: one step lower:
//}
//switch(FEAT_SIGNALS, SELF, newname, getbits(extra_callback_info2, 8, 8)){
//  00: signal;
//  01: semaphore;
//}
//
//  note in the following programmable and no entry need to be enabled
//switch(FEAT_SIGNALS, SELF, newname, getbits(extra_callback_info2, 16, 8)){
//  00: normal;
//  01: entry;
//  02: exit;
//  03: combo;
//  04: path;
//  05: path one way;
//  06: programmable;
//  07: no entry;
//}
//(getbits(extra_callback_info2, 16, 8)

switch(FEAT_SIGNALS, SELF, SABP_S, getbits(extra_callback_info2, 0, 8)){
    00: signal_SABP_S_STP;
    01: signal_SABP_S_CLR;
    05: signal_SABP_S_CLR;
    04: signal_SABP_S_CLR;
    03: signal_SABP_S_CLR;
    02: signal_SABP_S_APR;
}

switch(FEAT_SIGNALS, SELF, SABP_L, getbits(extra_callback_info2, 0, 8)){
    00: signal_SABP_L_STP;
    01: signal_SABP_L_CLR;
    05: signal_SABP_L_CLR;
    04: signal_SABP_L_CLR;
    03: signal_SABP_L_CLR;
    02: signal_SABP_L_APR;
}

switch(FEAT_SIGNALS, SELF, DAB_S, getbits(extra_callback_info2, 0, 8)){
    00: signal_DAB_S_STP;
    01: signal_DAB_S_CLR;
    05: signal_DAB_S_AAL;
    04: signal_DAB_S_APM;
    03: signal_DAB_S_AAP;
    02: signal_DAB_S_APR;
}

switch(FEAT_SIGNALS, SELF, DAP_S, getbits(extra_callback_info2, 0, 8)){
    00: signal_DAP_S_STP;
    01: signal_DAP_S_CLR;
    05: signal_DAP_S_CLR;
    04: signal_DAP_S_CLR;
    03: signal_DAP_S_MCL;
    02: signal_DAP_S_APR;
}

switch(FEAT_SIGNALS, SELF, DAB_L, getbits(extra_callback_info2, 0, 8)){
    00: signal_DAB_L_STP;
    01: signal_DAB_L_CLR;
    05: signal_DAB_L_AAL;
    04: signal_DAB_L_APM;
    03: signal_DAB_L_AAP;
    02: signal_DAB_L_APR;
}

switch(FEAT_SIGNALS, SELF, DAP_L, getbits(extra_callback_info2, 0, 8)){
    00: signal_DAP_L_STP;
    01: signal_DAP_L_CLR;
    05: signal_DAP_L_CLR;
    04: signal_DAP_L_CLR;
    03: signal_DAP_L_MCL;
    02: signal_DAP_L_APR;
}

// switch(FEAT_SIGNALS, SELF, TAB_S, getbits(extra_callback_info2, 0, 8)){
//     00: signal_TAB_S_STP;
//     01: signal_TAB_S_CLR;
//     05: signal_TAB_S_AAL;
//     04: signal_TAB_S_APM;
//     03: signal_TAB_S_APS;
//     02: signal_TAB_S_APR;
// }

// switch(FEAT_SIGNALS, SELF, TAP_S, getbits(extra_callback_info2, 0, 8)){
//     00: signal_TAP_S_STP;
//     01: signal_TAP_S_CLR;
//     05: signal_TAP_S_CLR;
//     04: signal_TAP_S_LCL;
//     03: signal_TAP_S_MCL;
//     02: signal_TAP_S_SCL;
// }

// switch(FEAT_SIGNALS, SELF, TAB_L, getbits(extra_callback_info2, 0, 8)){
//     00: signal_TAB_L_STP;
//     01: signal_TAB_L_CLR;
//     05: signal_TAB_L_AAL;
//     04: signal_TAB_L_APM;
//     03: signal_TAB_L_APS;
//     02: signal_TAB_L_APR;
// }

// switch(FEAT_SIGNALS, SELF, TAP_L, getbits(extra_callback_info2, 0, 8)){
//     00: signal_TAP_L_STP;
//     01: signal_TAP_L_CLR;
//     05: signal_TAP_L_CLR;
//     04: signal_TAP_L_LCL;
//     03: signal_TAP_L_MCL;
//     02: signal_TAP_L_SCL;
// }

switch(FEAT_SIGNALS, SELF, SABP, getbits(extra_callback_info2, 8, 8)){
    00: SABP_L;
    01: SABP_S;
}

switch(FEAT_SIGNALS, SELF, DAB, getbits(extra_callback_info2, 8, 8)){
    00: DAB_L;
    01: DAB_S;
}

switch(FEAT_SIGNALS, SELF, DAP, getbits(extra_callback_info2, 8, 8)){
    00: DAP_L;
    01: DAP_S;
}

// switch(FEAT_SIGNALS, SELF, TAB, getbits(extra_callback_info2, 8, 8)){
//     00: TAB_L;
//     01: TAB_S;
// }

// switch(FEAT_SIGNALS, SELF, TAP, getbits(extra_callback_info2, 8, 8)){
//     00: TAP_L;
//     01: TAP_S;
// }

switch(FEAT_SIGNALS, SELF, Singles, getbits(extra_callback_info2, 16, 8)){
    00: SABP;
    01: SABP;
    02: SABP;
    03: SABP;
    04: SABP;
    05: SABP;
    06: SABP;
    07: SABP;
}

switch(FEAT_SIGNALS, SELF, Doubles, getbits(extra_callback_info2, 16, 8)){
    00: DAB;
    01: DAP;
    02: DAP;
    03: DAP;
    04: DAP;
    05: DAP;
    06: DAP;
    07: DAP;
}

// switch(FEAT_SIGNALS, SELF, Triples, getbits(extra_callback_info2, 16, 8)){
//     00: TAB;
//     01: TAP;
//     02: TAP;
//     03: TAP;
//     04: TAP;
//     05: TAP;
//     06: TAP;
//     07: TAP;
// }

switch(FEAT_SIGNALS, SELF, listed_signals, signal_style){
    01: Singles;
    02: Doubles;
    // 03: Triples;
}

item (FEAT_SIGNALS, custom_signals, 0) {
    property {
        extra_aspects:      4;

        define_style:       1; // single-head
        style_name:         string(STR_SIG_SINGLE);
        style_semaphore_enabled: bitmask(SIGNAL_TYPE_NORMAL, SIGNAL_TYPE_PBS, SIGNAL_TYPE_PBS_ONEWAY);
        style_electric_enabled: bitmask(SIGNAL_TYPE_NORMAL, SIGNAL_TYPE_PBS, SIGNAL_TYPE_PBS_ONEWAY);

        define_style:       2; // double-head
        style_name:         string(STR_SIG_DOUBLE);
        style_semaphore_enabled: bitmask(SIGNAL_TYPE_NORMAL, SIGNAL_TYPE_PBS, SIGNAL_TYPE_PBS_ONEWAY);
        style_electric_enabled: bitmask(SIGNAL_TYPE_NORMAL, SIGNAL_TYPE_PBS, SIGNAL_TYPE_PBS_ONEWAY);

        // define_style:       3;
        // style_name:         string(STR_SIG_TRIPLE);
        // style_electric_enabled: bitmask(SIGNAL_TYPE_NORMAL, SIGNAL_TYPE_PBS, SIGNAL_TYPE_PBS_ONEWAY);
        // style_electric_enabled: bitmask(SIGNAL_TYPE_NORMAL, SIGNAL_TYPE_PBS, SIGNAL_TYPE_PBS_ONEWAY);
    }

    graphics {
        listed_signals;
    }
}
